'use strict';

var contentType = require('content-type');
var express = require('express');
var Router = require('express-promise-router');
var index = require('./body-parser/index.cjs.js');
var RequestValidationContextImpl = require('./validation/RequestValidationContextImpl.cjs.js');
var errors = require('./errors.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var contentType__default = /*#__PURE__*/_interopDefaultCompat(contentType);
var express__default = /*#__PURE__*/_interopDefaultCompat(express);
var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);

class HttpPostIngressEventPublisher {
  static fromConfig(env) {
    const topics = env.config.getOptionalStringArray("events.http.topics") ?? [];
    const ingresses = env.ingresses ?? {};
    topics.forEach((topic) => {
      if (!ingresses[topic]) {
        ingresses[topic] = {};
      }
    });
    const parsers = { ...index.defaultHttpBodyParsers, ...env.bodyParsers };
    return new HttpPostIngressEventPublisher(
      env.events,
      env.logger,
      ingresses,
      parsers
    );
  }
  events;
  logger;
  ingresses;
  bodyParsers;
  constructor(events, logger, ingresses, bodyParsers) {
    this.events = events;
    this.logger = logger;
    this.ingresses = ingresses;
    this.bodyParsers = bodyParsers;
  }
  bind(router) {
    router.use("/http", this.createRouter(this.ingresses));
  }
  createRouter(ingresses) {
    const router = Router__default.default();
    router.use(express__default.default.raw({ type: "*/*", limit: "5mb" }));
    Object.keys(ingresses).forEach(
      (topic) => this.addRouteForTopic(router, topic, ingresses[topic].validator)
    );
    return router;
  }
  addRouteForTopic(router, topic, validator) {
    const path = `/${topic}`;
    const logger = this.logger;
    router.post(path, async (request, response) => {
      const requestContentType = contentType__default.default.parse(request);
      const bodyParser = this.bodyParsers[requestContentType.type ?? ""];
      if (!bodyParser) {
        throw new errors.UnsupportedMediaTypeError(requestContentType.type);
      }
      const { bodyParsed, bodyBuffer, encoding } = await bodyParser(
        request,
        requestContentType,
        topic
      );
      if (validator) {
        const requestDetails = {
          body: bodyParsed,
          headers: request.headers,
          raw: {
            body: bodyBuffer,
            encoding
          }
        };
        const context = new RequestValidationContextImpl.RequestValidationContextImpl();
        await validator(requestDetails, context);
        if (context.wasRejected()) {
          response.status(context.rejectionDetails.status).json(context.rejectionDetails.payload);
          return;
        }
      }
      await this.events.publish({
        topic,
        eventPayload: bodyParsed,
        metadata: request.headers
      });
      response.status(202).json({ status: "accepted" });
    });
    logger.info(`Registered /api/events/http${path} to receive events`);
  }
}

exports.HttpPostIngressEventPublisher = HttpPostIngressEventPublisher;
//# sourceMappingURL=HttpPostIngressEventPublisher.cjs.js.map
