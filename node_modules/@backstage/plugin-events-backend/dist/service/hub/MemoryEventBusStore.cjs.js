'use strict';

var errors = require('@backstage/errors');

const MAX_BATCH_SIZE = 10;
const MAX_EVENTS_DEFAULT = 1e3;
class MemoryEventBusStore {
  #maxEvents;
  #events = new Array();
  #subscribers = /* @__PURE__ */ new Map();
  #listeners = /* @__PURE__ */ new Set();
  constructor(options = {}) {
    this.#maxEvents = options.maxEvents ?? MAX_EVENTS_DEFAULT;
  }
  async publish(options) {
    const topic = options.event.topic;
    const notifiedSubscribers = new Set(options.notifiedSubscribers);
    let hasOtherSubscribers = false;
    for (const sub of this.#subscribers.values()) {
      if (sub.topics.has(topic) && !notifiedSubscribers.has(sub.id)) {
        hasOtherSubscribers = true;
        break;
      }
    }
    if (!hasOtherSubscribers) {
      return void 0;
    }
    const nextSeq = this.#getMaxSeq() + 1;
    this.#events.push({ ...options.event, notifiedSubscribers, seq: nextSeq });
    for (const listener of this.#listeners) {
      if (listener.topics.has(topic)) {
        listener.resolve({ topic });
        this.#listeners.delete(listener);
      }
    }
    if (this.#events.length > this.#maxEvents) {
      this.#events.shift();
    }
    return { eventId: String(nextSeq) };
  }
  #getMaxSeq() {
    return this.#events[this.#events.length - 1]?.seq ?? 0;
  }
  async upsertSubscription(id, topics) {
    const existing = this.#subscribers.get(id);
    if (existing) {
      existing.topics = new Set(topics);
      return;
    }
    const sub = {
      id,
      seq: this.#getMaxSeq(),
      topics: new Set(topics)
    };
    this.#subscribers.set(id, sub);
  }
  async readSubscription(id) {
    const sub = this.#subscribers.get(id);
    if (!sub) {
      throw new errors.NotFoundError(`Subscription not found`);
    }
    const events = this.#events.filter(
      (event) => event.seq > sub.seq && sub.topics.has(event.topic) && !event.notifiedSubscribers.has(id)
    ).slice(0, MAX_BATCH_SIZE);
    sub.seq = events[events.length - 1]?.seq ?? sub.seq;
    return {
      events: events.map(({ topic, eventPayload }) => ({
        topic,
        eventPayload
      }))
    };
  }
  async setupListener(subscriptionId, options) {
    return {
      waitForUpdate: async () => {
        options.signal.throwIfAborted();
        const sub = this.#subscribers.get(subscriptionId);
        if (!sub) {
          throw new errors.NotFoundError(`Subscription not found`);
        }
        return new Promise((resolve, reject) => {
          const listener = {
            topics: sub.topics,
            resolve(result) {
              resolve(result);
              cleanup();
            }
          };
          this.#listeners.add(listener);
          const onAbort = () => {
            this.#listeners.delete(listener);
            reject(options.signal.reason);
            cleanup();
          };
          function cleanup() {
            options.signal.removeEventListener("abort", onAbort);
          }
          options.signal.addEventListener("abort", onAbort);
        });
      }
    };
  }
}

exports.MemoryEventBusStore = MemoryEventBusStore;
//# sourceMappingURL=MemoryEventBusStore.cjs.js.map
