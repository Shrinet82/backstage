'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var errors = require('@backstage/errors');
var types = require('@backstage/types');

const WINDOW_MAX_COUNT_DEFAULT = 1e4;
const WINDOW_MIN_AGE_DEFAULT = { minutes: 10 };
const WINDOW_MAX_AGE_DEFAULT = { days: 1 };
const MAX_BATCH_SIZE = 10;
const LISTENER_CONNECTION_TIMEOUT_MS = 6e4;
const KEEPALIVE_INTERVAL_MS = 6e4;
const TABLE_EVENTS = "event_bus_events";
const TABLE_SUBSCRIPTIONS = "event_bus_subscriptions";
const TOPIC_PUBLISH = "event_bus_publish";
function creatorId(credentials) {
  return `service=${credentials.principal.subject}`;
}
const migrationsDir = backendPluginApi.resolvePackagePath(
  "@backstage/plugin-events-backend",
  "migrations"
);
class DatabaseEventBusListener {
  #client;
  #logger;
  #listeners = /* @__PURE__ */ new Set();
  #isShuttingDown = false;
  #connPromise;
  #connTimeout;
  #keepaliveInterval;
  constructor(client, logger) {
    this.#client = client;
    this.#logger = logger.child({ type: "DatabaseEventBusListener" });
  }
  async setupListener(topics, signal) {
    if (this.#connTimeout) {
      clearTimeout(this.#connTimeout);
      this.#connTimeout = void 0;
    }
    await this.#ensureConnection();
    const updatePromise = new Promise((resolve, reject) => {
      const listener = {
        topics,
        resolve(result) {
          resolve(result);
          cleanup();
        },
        reject(err) {
          reject(err);
          cleanup();
        }
      };
      this.#listeners.add(listener);
      const onAbort = () => {
        this.#listeners.delete(listener);
        this.#maybeTimeoutConnection();
        reject(signal.reason);
        cleanup();
      };
      function cleanup() {
        signal.removeEventListener("abort", onAbort);
      }
      signal.addEventListener("abort", onAbort);
    });
    updatePromise.catch(() => {
    });
    return { waitForUpdate: () => updatePromise };
  }
  async shutdown() {
    if (this.#isShuttingDown) {
      return;
    }
    this.#isShuttingDown = true;
    const conn = await this.#connPromise?.catch(() => void 0);
    if (conn) {
      this.#destroyConnection(conn);
    }
  }
  #handleNotify(topic) {
    this.#logger.debug(`Listener received notification for topic '${topic}'`);
    for (const l of this.#listeners) {
      if (l.topics.has(topic)) {
        l.resolve({ topic });
        this.#listeners.delete(l);
      }
    }
    this.#maybeTimeoutConnection();
  }
  // We don't try to reconnect on error, instead we notify all listeners and let
  // them try to establish a new connection
  #handleError(error) {
    this.#logger.error(
      `Listener connection failed, notifying all listeners`,
      error
    );
    for (const l of this.#listeners) {
      l.reject(new Error("Listener connection failed"));
    }
    this.#listeners.clear();
    this.#maybeTimeoutConnection();
  }
  #maybeTimeoutConnection() {
    if (this.#listeners.size === 0 && !this.#connTimeout) {
      this.#connTimeout = setTimeout(() => {
        this.#connTimeout = void 0;
        this.#connPromise?.then((conn) => {
          this.#logger.info("Listener connection timed out, destroying");
          this.#connPromise = void 0;
          this.#destroyConnection(conn);
        });
      }, LISTENER_CONNECTION_TIMEOUT_MS);
    }
  }
  #destroyConnection(conn) {
    if (this.#keepaliveInterval) {
      clearInterval(this.#keepaliveInterval);
      this.#keepaliveInterval = void 0;
    }
    this.#client.destroyRawConnection(conn).catch((error) => {
      this.#logger.error(`Listener failed to destroy connection`, error);
    });
    conn.removeAllListeners();
  }
  async #ensureConnection() {
    if (this.#isShuttingDown) {
      throw new Error("Listener is shutting down");
    }
    if (this.#connPromise) {
      await this.#connPromise;
      return;
    }
    this.#connPromise = Promise.resolve().then(async () => {
      const conn = await this.#client.acquireRawConnection();
      try {
        await conn.query(`LISTEN ${TOPIC_PUBLISH}`);
        if (this.#keepaliveInterval) {
          clearInterval(this.#keepaliveInterval);
        }
        this.#keepaliveInterval = setInterval(() => {
          conn.query("select 1").catch((error) => {
            this.#connPromise = void 0;
            this.#destroyConnection(conn);
            this.#handleError(new errors.ForwardedError("Keepalive failed", error));
          });
        }, KEEPALIVE_INTERVAL_MS);
        conn.on("notification", (event) => {
          this.#handleNotify(event.payload);
        });
        conn.on("error", (error) => {
          this.#connPromise = void 0;
          this.#destroyConnection(conn);
          this.#handleError(error);
        });
        conn.on("end", (error) => {
          this.#connPromise = void 0;
          this.#destroyConnection(conn);
          this.#handleError(
            error ?? new Error("Connection ended unexpectedly")
          );
        });
        return conn;
      } catch (error) {
        this.#destroyConnection(conn);
        throw error;
      }
    });
    try {
      await this.#connPromise;
    } catch (error) {
      this.#connPromise = void 0;
      throw error;
    }
  }
}
class DatabaseEventBusStore {
  static async create(options) {
    const db = await options.database.getClient();
    if (db.client.config.client !== "pg") {
      throw new Error(
        `DatabaseEventBusStore only supports PostgreSQL, got '${db.client.config.client}'`
      );
    }
    if (!options.database.migrations?.skip) {
      await db.migrate.latest({
        directory: migrationsDir
      });
    }
    const listener = new DatabaseEventBusListener(db.client, options.logger);
    const store = new DatabaseEventBusStore(
      db,
      options.logger,
      listener,
      options.window?.maxCount ?? WINDOW_MAX_COUNT_DEFAULT,
      types.durationToMilliseconds(options.window?.minAge ?? WINDOW_MIN_AGE_DEFAULT),
      types.durationToMilliseconds(options.window?.maxAge ?? WINDOW_MAX_AGE_DEFAULT)
    );
    await options.scheduler.scheduleTask({
      id: "event-bus-cleanup",
      frequency: { seconds: 10 },
      timeout: { minutes: 1 },
      initialDelay: { seconds: 10 },
      fn: () => store.#cleanup()
    });
    options.lifecycle.addShutdownHook(async () => {
      await listener.shutdown();
    });
    return store;
  }
  /** @internal */
  static async forTest({
    db,
    logger,
    minAge = 0,
    maxAge = 1e4
  }) {
    await db.migrate.latest({ directory: migrationsDir });
    const store = new DatabaseEventBusStore(
      db,
      logger,
      new DatabaseEventBusListener(db.client, logger),
      5,
      minAge,
      maxAge
    );
    return Object.assign(store, { clean: () => store.#cleanup() });
  }
  #db;
  #logger;
  #listener;
  #windowMaxCount;
  #windowMinAge;
  #windowMaxAge;
  constructor(db, logger, listener, windowMaxCount, windowMinAge, windowMaxAge) {
    this.#db = db;
    this.#logger = logger;
    this.#listener = listener;
    this.#windowMaxCount = windowMaxCount;
    this.#windowMinAge = windowMinAge;
    this.#windowMaxAge = windowMaxAge;
  }
  async publish(options) {
    const topic = options.event.topic;
    const notifiedSubscribers = options.notifiedSubscribers ?? [];
    const result = await this.#db.into(
      this.#db.raw("?? (??, ??, ??, ??)", [
        TABLE_EVENTS,
        // These are the rows that we insert, and should match the SELECT below
        "created_by",
        "topic",
        "data_json",
        "notified_subscribers"
      ])
    ).insert(
      (q) => q.select(
        this.#db.raw("?", [creatorId(options.credentials)]),
        this.#db.raw("?", [topic]),
        this.#db.raw("?", [
          JSON.stringify({
            payload: options.event.eventPayload,
            metadata: options.event.metadata
          })
        ]),
        this.#db.raw("?", [notifiedSubscribers])
      ).from(TABLE_SUBSCRIPTIONS).whereNotIn("id", notifiedSubscribers).andWhere(this.#db.raw("? = ANY(topics)", [topic])).having(this.#db.raw("count(*)"), ">", 0)
      // Check if there are any results
    ).returning("id");
    if (result.length === 0) {
      return void 0;
    }
    if (result.length > 1) {
      throw new Error(
        `Failed to insert event, unexpectedly updated ${result.length} rows`
      );
    }
    const [{ id }] = result;
    const notifyResult = await this.#db.select(
      this.#db.raw(`pg_notify(?, ?)`, [TOPIC_PUBLISH, topic])
    );
    if (notifyResult?.length !== 1) {
      this.#logger.warn(
        `Failed to notify subscribers of event with ID '${id}' on topic '${topic}'`
      );
    }
    return { eventId: id };
  }
  async upsertSubscription(id, topics, credentials) {
    const [{ max: maxId }] = await this.#db(TABLE_EVENTS).max("id");
    const result = await this.#db(TABLE_SUBSCRIPTIONS).insert({
      id,
      created_by: creatorId(credentials),
      updated_at: this.#db.fn.now(),
      topics,
      read_until: maxId || 0
    }).onConflict("id").merge(["created_by", "topics", "updated_at"]).returning("*");
    if (result.length !== 1) {
      throw new Error(
        `Failed to upsert subscription, updated ${result.length} rows`
      );
    }
  }
  async readSubscription(id) {
    const { rows: result } = await this.#db.raw(
      `
      WITH subscription AS (
        SELECT topics, read_until
        FROM event_bus_subscriptions
        WHERE id = :id
        FOR UPDATE
      ),
      selected_events AS (
        SELECT event_bus_events.*
        FROM event_bus_events
        INNER JOIN subscription
        ON event_bus_events.topic = ANY(subscription.topics)
        WHERE event_bus_events.id > subscription.read_until
        AND NOT :id = ANY(event_bus_events.notified_subscribers)
        ORDER BY event_bus_events.id ASC LIMIT :limit
      ),
      last_event_id AS (
        SELECT max(id) AS last_event_id
        FROM selected_events
      ),
      events_array AS (
        SELECT json_agg(row_to_json(selected_events)) AS events
        FROM selected_events
      )
      UPDATE event_bus_subscriptions
      SET read_until = COALESCE(last_event_id, (SELECT MAX(id) FROM event_bus_events), 0)
      FROM events_array, last_event_id
      WHERE event_bus_subscriptions.id = :id
      RETURNING events_array.events
    `,
      { id, limit: MAX_BATCH_SIZE }
    );
    if (result.length === 0) {
      throw new errors.NotFoundError(`Subscription with ID '${id}' not found`);
    } else if (result.length > 1) {
      throw new Error(
        `Failed to read subscription, unexpectedly updated ${result.length} rows`
      );
    }
    const rows = result[0].events;
    if (!rows || rows.length === 0) {
      return { events: [] };
    }
    return {
      events: rows.map((row) => {
        const { payload, metadata } = JSON.parse(row.data_json);
        return {
          topic: row.topic,
          eventPayload: payload,
          metadata
        };
      })
    };
  }
  async setupListener(subscriptionId, options) {
    const result = await this.#db(TABLE_SUBSCRIPTIONS).select("topics").where({ id: subscriptionId }).first();
    if (!result) {
      throw new errors.NotFoundError(
        `Subscription with ID '${subscriptionId}' not found`
      );
    }
    options.signal.throwIfAborted();
    return this.#listener.setupListener(
      new Set(result.topics ?? []),
      options.signal
    );
  }
  async #cleanup() {
    try {
      const eventCount = await this.#db(TABLE_EVENTS).delete().orWhere(
        (inner) => inner.whereIn(
          "id",
          this.#db.select("id").from(TABLE_EVENTS).orderBy("id", "desc").offset(this.#windowMaxCount)
        ).andWhere(
          "created_at",
          "<",
          new Date(Date.now() - this.#windowMinAge)
        )
      ).orWhere("created_at", "<", new Date(Date.now() - this.#windowMaxAge));
      if (eventCount > 0) {
        this.#logger.info(
          `Event cleanup resulted in ${eventCount} old events being deleted`
        );
      }
    } catch (error) {
      this.#logger.error("Event cleanup failed", error);
    }
    try {
      const [{ min: minId }] = await this.#db(TABLE_EVENTS).min("id");
      let subscriberCount;
      if (minId === null) {
        subscriberCount = await this.#db(TABLE_SUBSCRIPTIONS).where("updated_at", "<", new Date(Date.now() - this.#windowMaxAge)).delete();
      } else {
        subscriberCount = await this.#db(TABLE_SUBSCRIPTIONS).delete().where("read_until", "<", minId - 1);
      }
      if (subscriberCount > 0) {
        this.#logger.info(
          `Subscription cleanup resulted in ${subscriberCount} stale subscribers being deleted`
        );
      }
    } catch (error) {
      this.#logger.error("Subscription cleanup failed", error);
    }
  }
}

exports.DatabaseEventBusStore = DatabaseEventBusStore;
//# sourceMappingURL=DatabaseEventBusStore.cjs.js.map
