'use strict';

var router = require('../../schema/openapi/generated/router.cjs.js');
var MemoryEventBusStore = require('./MemoryEventBusStore.cjs.js');
var DatabaseEventBusStore = require('./DatabaseEventBusStore.cjs.js');
var pluginEventsNode = require('@backstage/plugin-events-node');

const DEFAULT_NOTIFY_TIMEOUT_MS = 55e3;
async function createEventBusStore(deps) {
  const db = await deps.database.getClient();
  if (db.client.config.client === "pg") {
    deps.logger.info("Database is PostgreSQL, using database store");
    return await DatabaseEventBusStore.DatabaseEventBusStore.create(deps);
  }
  deps.logger.info("Database is not PostgreSQL, using memory store");
  return new MemoryEventBusStore.MemoryEventBusStore();
}
async function createEventBusRouter(options) {
  const { httpAuth, notifyTimeoutMs = DEFAULT_NOTIFY_TIMEOUT_MS } = options;
  const logger = options.logger.child({ type: "EventBus" });
  const store = await createEventBusStore(options);
  const apiRouter = await router.createOpenApiRouter();
  apiRouter.post("/bus/v1/events", async (req, res) => {
    const credentials = await httpAuth.credentials(req, {
      allow: ["service"]
    });
    const topic = req.body.event.topic;
    const notifiedSubscribers = req.body.notifiedSubscribers;
    const result = await store.publish({
      event: {
        topic,
        eventPayload: req.body.event.payload
      },
      notifiedSubscribers,
      credentials
    });
    if (result) {
      logger.debug(
        `Published event to '${topic}' with ID '${result.eventId}'`,
        {
          subject: credentials.principal.subject
        }
      );
      res.status(201).end();
    } else {
      if (notifiedSubscribers) {
        const notified = `'${notifiedSubscribers.join("', '")}'`;
        logger.debug(
          `Skipped publishing of event to '${topic}', subscribers have already been notified: ${notified}`,
          { subject: credentials.principal.subject }
        );
      } else {
        logger.debug(
          `Skipped publishing of event to '${topic}', no subscribers present`,
          { subject: credentials.principal.subject }
        );
      }
      res.status(204).end();
    }
  });
  apiRouter.get(
    "/bus/v1/subscriptions/:subscriptionId/events",
    async (req, res) => {
      const credentials = await httpAuth.credentials(req, {
        allow: ["service"]
      });
      const id = req.params.subscriptionId;
      const controller = new AbortController();
      req.on("end", () => controller.abort());
      const listener = await store.setupListener(id, {
        signal: controller.signal
      });
      const timeout = setTimeout(() => {
        controller.abort();
      }, notifyTimeoutMs);
      try {
        const { events } = await store.readSubscription(id);
        logger.debug(
          `Reading subscription '${id}' resulted in ${events.length} events`,
          { subject: credentials.principal.subject }
        );
        if (events.length > 0) {
          res.json({
            events: events.map((event) => ({
              topic: event.topic,
              payload: event.eventPayload
            }))
          });
        } else {
          res.setHeader(
            pluginEventsNode.EVENTS_NOTIFY_TIMEOUT_HEADER,
            notifyTimeoutMs.toString()
          );
          res.status(202);
          res.flushHeaders();
          try {
            const { topic } = await listener.waitForUpdate();
            logger.debug(
              `Received notification for subscription '${id}' for topic '${topic}'`,
              { subject: credentials.principal.subject }
            );
          } catch (error) {
            if (error !== controller.signal.reason) {
              logger.error(`Error listening for subscription '${id}'`, error);
            }
          } finally {
            await new Promise(
              (resolve) => setTimeout(resolve, 1 + Math.random() * 9)
            );
            res.end();
          }
        }
      } finally {
        controller.abort();
        clearTimeout(timeout);
      }
    }
  );
  apiRouter.put("/bus/v1/subscriptions/:subscriptionId", async (req, res) => {
    const credentials = await httpAuth.credentials(req, {
      allow: ["service"]
    });
    const id = req.params.subscriptionId;
    await store.upsertSubscription(id, req.body.topics, credentials);
    logger.debug(
      `New subscription '${id}' for topics '${req.body.topics.join("', '")}'`,
      { subject: credentials.principal.subject }
    );
    res.status(201).end();
  });
  return apiRouter;
}

exports.createEventBusRouter = createEventBusRouter;
//# sourceMappingURL=createEventBusRouter.cjs.js.map
