{"version":3,"file":"createEventBusRouter.cjs.js","sources":["../../../src/service/hub/createEventBusRouter.ts"],"sourcesContent":["/*\n * Copyright 2024 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DatabaseService,\n  HttpAuthService,\n  LifecycleService,\n  LoggerService,\n  SchedulerService,\n} from '@backstage/backend-plugin-api';\nimport { Handler } from 'express';\nimport { createOpenApiRouter } from '../../schema/openapi';\nimport { MemoryEventBusStore } from './MemoryEventBusStore';\nimport { DatabaseEventBusStore } from './DatabaseEventBusStore';\nimport { EventBusStore } from './types';\nimport {\n  EVENTS_NOTIFY_TIMEOUT_HEADER,\n  EventParams,\n} from '@backstage/plugin-events-node';\n\nconst DEFAULT_NOTIFY_TIMEOUT_MS = 55_000; // Just below 60s, which is a common HTTP timeout\n\n/*\n\n# Event Bus\n\nThis comment describes the event bus that is implemented here in the events\nbackend, and by default used by the events service.\n\n## Overview\n\nThe events bus implements a subscription mechanism where subscribers must exist\nupfront for events to be stored. It uses a single inbox for all events, with\neach subscriber having its own pointer for how far into the inbox it has read.\n\nIn order to avoid busy polling, the API uses a long-polling mechanism where a\nrequest is left hanging until the client should try to read again.\n\nThe event bus is not implemented with any guarantees of events being consumed,\nbut it does aim to make it unlikely that events are dropped\n\n## API\n\n### POST /bus/v1/events\n\nThis endpoint is used to publish new events to the event bus on a specific\ntopic. It can optionally include a set of subscription IDs for subscribers that\nhave already been notified of the event. This is to enable an optimization where\nwe notify subscribers locally if possible, and avoid the need for events to be\nrelayed through the events bus at all of possible.\n\nFor an event to be published and stored there must already exist a subscriber\nthat is subscribed to the event's topic, and that hasn't already been notified\nof the event. If no such subscriber is found, the event will be discarded.\n\n### PUT /bus/v1/subscriptions/:subscriptionId\n\nThis endpoint is used to create or update a subscriptions. Subscriptions are\nshared across the entire bus and divided by subscription ID. Multiple clients\ncan be reading events from the same subscription at the same time, but only one\nof those clients will receive each event. This enables division of work by using\nthe same subscriber ID across multiple instances, as well as broadcasting by\nensuring separate subscribers IDs.\n\n### GET /bus/v1/subscriptions/:subscriptionId/events\n\nThis endpoint is used to read events from a subscription. It will return a batch\nof events for the subscribed topics that have not yet been read by the\nsubscription. If no such events are available, the endpoint will return a 202\nresponse and then hang end response until an event is available or a timeout is\nreached. This allows clients to call this endpoint in a loop but will keep\ntraffic overhead fairly low.\n\n## Delivery guarantees\n\nWhen reading events from the event bus, clients should always implement a\ngraceful shutdown where they process any events that are received from the\nevents endpoint before shutting down. This is also the reason that the events\nendpoint does not return any events when responding with a 202 blocking the\nresponse, because there would otherwise be a race condition where the events\nmight be lost in transit if the client shuts down. By always sending an empty\nresponse and requiring the client to send another request, we ensure that the\nclient is prepared to halt shutdown until the request had been fully processed.\n\n## Local processing optimization\n\nWhen possible, events will be processed locally before sent to the event bus.\nThe client will also inform the bus of which subscriptions have already been\nnotified of the event, so that the bus can completely avoid storing an event if\nit has already been fully consumed by all subscribers.\n\n## Automated cleanup & event window\n\nEvents are deleted once they are outside the guaranteed storage window. By\ndefault the window 10 minutes for all events, and 24 hours for the last 10000\nevents. This ensures that the event log doesn't grow indefinitely, while still\nallowing subscribers with restarts or outages to catch up to past events,\nensuring that events are likely not lost.\n\nSubscriptions are also cleaned up if their read pointer falls outside of the\ncurrent event window. This ensures that stale subscribers don't accumulate and\ncause unnecessary storage of events.\n\n*/\n\nasync function createEventBusStore(deps: {\n  logger: LoggerService;\n  database: DatabaseService;\n  scheduler: SchedulerService;\n  lifecycle: LifecycleService;\n  httpAuth: HttpAuthService;\n}): Promise<EventBusStore> {\n  const db = await deps.database.getClient();\n  if (db.client.config.client === 'pg') {\n    deps.logger.info('Database is PostgreSQL, using database store');\n    return await DatabaseEventBusStore.create(deps);\n  }\n\n  deps.logger.info('Database is not PostgreSQL, using memory store');\n  return new MemoryEventBusStore();\n}\n\n/**\n * Creates a new event bus router\n * @internal\n */\nexport async function createEventBusRouter(options: {\n  logger: LoggerService;\n  database: DatabaseService;\n  scheduler: SchedulerService;\n  lifecycle: LifecycleService;\n  httpAuth: HttpAuthService;\n  notifyTimeoutMs?: number; // for testing\n}): Promise<Handler> {\n  const { httpAuth, notifyTimeoutMs = DEFAULT_NOTIFY_TIMEOUT_MS } = options;\n  const logger = options.logger.child({ type: 'EventBus' });\n\n  const store = await createEventBusStore(options);\n\n  const apiRouter = await createOpenApiRouter();\n\n  apiRouter.post('/bus/v1/events', async (req, res) => {\n    const credentials = await httpAuth.credentials(req, {\n      allow: ['service'],\n    });\n    const topic = req.body.event.topic;\n    const notifiedSubscribers = req.body.notifiedSubscribers;\n    const result = await store.publish({\n      event: {\n        topic,\n        eventPayload: req.body.event.payload,\n      } as EventParams,\n      notifiedSubscribers,\n      credentials,\n    });\n    if (result) {\n      logger.debug(\n        `Published event to '${topic}' with ID '${result.eventId}'`,\n        {\n          subject: credentials.principal.subject,\n        },\n      );\n      res.status(201).end();\n    } else {\n      if (notifiedSubscribers) {\n        const notified = `'${notifiedSubscribers.join(\"', '\")}'`;\n        logger.debug(\n          `Skipped publishing of event to '${topic}', subscribers have already been notified: ${notified}`,\n          { subject: credentials.principal.subject },\n        );\n      } else {\n        logger.debug(\n          `Skipped publishing of event to '${topic}', no subscribers present`,\n          { subject: credentials.principal.subject },\n        );\n      }\n      res.status(204).end();\n    }\n  });\n\n  apiRouter.get(\n    '/bus/v1/subscriptions/:subscriptionId/events',\n    async (req, res) => {\n      const credentials = await httpAuth.credentials(req, {\n        allow: ['service'],\n      });\n      const id = req.params.subscriptionId;\n\n      const controller = new AbortController();\n      req.on('end', () => controller.abort());\n\n      // By setting up the listener first we make sure we don't miss any events\n      // that are published while reading. If an event is published we'll receive\n      // a notification, which we may ignore depending on the outcome of the read\n      const listener = await store.setupListener(id, {\n        signal: controller.signal,\n      });\n\n      // By timing out requests we make sure they don't stall or that events get stuck.\n      // For the caller there's no difference between a timeout and a\n      // notification, either way they should try reading again.\n      const timeout = setTimeout(() => {\n        controller.abort();\n      }, notifyTimeoutMs);\n\n      try {\n        const { events } = await store.readSubscription(id);\n\n        logger.debug(\n          `Reading subscription '${id}' resulted in ${events.length} events`,\n          { subject: credentials.principal.subject },\n        );\n\n        if (events.length > 0) {\n          res.json({\n            events: events.map(event => ({\n              topic: event.topic,\n              payload: event.eventPayload,\n            })),\n          });\n        } else {\n          res.setHeader(\n            EVENTS_NOTIFY_TIMEOUT_HEADER,\n            notifyTimeoutMs.toString(),\n          );\n          res.status(202);\n          res.flushHeaders();\n\n          try {\n            const { topic } = await listener.waitForUpdate();\n            logger.debug(\n              `Received notification for subscription '${id}' for topic '${topic}'`,\n              { subject: credentials.principal.subject },\n            );\n          } catch (error) {\n            if (error !== controller.signal.reason) {\n              logger.error(`Error listening for subscription '${id}'`, error);\n            }\n          } finally {\n            // A small extra delay ensures a more even spread of events across\n            // consumers in case some consumers are faster than others\n            await new Promise(resolve =>\n              setTimeout(resolve, 1 + Math.random() * 9),\n            );\n            res.end();\n          }\n        }\n      } finally {\n        controller.abort();\n        clearTimeout(timeout);\n      }\n    },\n  );\n\n  apiRouter.put('/bus/v1/subscriptions/:subscriptionId', async (req, res) => {\n    const credentials = await httpAuth.credentials(req, {\n      allow: ['service'],\n    });\n    const id = req.params.subscriptionId;\n\n    await store.upsertSubscription(id, req.body.topics, credentials);\n\n    logger.debug(\n      `New subscription '${id}' for topics '${req.body.topics.join(\"', '\")}'`,\n      { subject: credentials.principal.subject },\n    );\n\n    res.status(201).end();\n  });\n\n  return apiRouter;\n}\n"],"names":["DatabaseEventBusStore","MemoryEventBusStore","createOpenApiRouter","EVENTS_NOTIFY_TIMEOUT_HEADER"],"mappings":"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"}