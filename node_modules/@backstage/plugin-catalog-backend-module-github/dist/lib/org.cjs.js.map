{"version":3,"file":"org.cjs.js","sources":["../../src/lib/org.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DEFAULT_NAMESPACE,\n  GroupEntity,\n  parseEntityRef,\n  stringifyEntityRef,\n  UserEntity,\n} from '@backstage/catalog-model';\n\nexport function buildOrgHierarchy(groups: GroupEntity[]) {\n  const groupsByName = new Map(groups.map(g => [g.metadata.name, g]));\n\n  //\n  // Make sure that g.parent.children contain g\n  //\n\n  for (const group of groups) {\n    const selfName = group.metadata.name;\n    const parentName = group.spec.parent;\n    if (parentName) {\n      const parent = groupsByName.get(parentName);\n      if (parent && !parent.spec.children.includes(selfName)) {\n        parent.spec.children.push(selfName);\n      }\n    }\n  }\n\n  //\n  // Make sure that g.children.parent is g\n  //\n\n  for (const group of groups) {\n    const selfName = group.metadata.name;\n    for (const childName of group.spec.children) {\n      const child = groupsByName.get(childName);\n      if (child && !child.spec.parent) {\n        child.spec.parent = selfName;\n      }\n    }\n  }\n}\n\n// Ensure that users have their direct group memberships.\nexport function assignGroupsToUsers(\n  users: UserEntity[],\n  groups: GroupEntity[],\n) {\n  const groupMemberUsers = new Map(\n    groups.map(group => {\n      const groupKey =\n        group.metadata.namespace &&\n        group.metadata.namespace !== DEFAULT_NAMESPACE\n          ? `${group.metadata.namespace}/${group.metadata.name}`\n          : group.metadata.name;\n      // Fully qualify member refs so they can be keyed off of since they may contain namespace prefixes\n      return [\n        groupKey,\n        group.spec.members?.map(m =>\n          stringifyEntityRef(parseEntityRef(m, { defaultKind: 'user' })),\n        ) || [],\n      ];\n    }),\n  );\n\n  const usersByRef = new Map(users.map(u => [stringifyEntityRef(u), u]));\n  for (const [groupName, userRefs] of groupMemberUsers.entries()) {\n    for (const ref of userRefs) {\n      const user = usersByRef.get(ref);\n      if (user && !user.spec.memberOf?.includes(groupName)) {\n        if (!user.spec.memberOf) {\n          user.spec.memberOf = [];\n        }\n        user.spec.memberOf.push(groupName);\n      }\n    }\n  }\n}\n\n// Assign all relevant groups to a single user if the user is a member of each group.\nexport function assignGroupsToUser(user: UserEntity, groups: GroupEntity[]) {\n  const userRef = stringifyEntityRef(user);\n  for (const group of groups) {\n    const groupKey =\n      group.metadata.namespace && group.metadata.namespace !== DEFAULT_NAMESPACE\n        ? `${group.metadata.namespace}/${group.metadata.name}`\n        : group.metadata.name;\n    const memberRefs =\n      group.spec.members?.map(m =>\n        stringifyEntityRef(parseEntityRef(m, { defaultKind: 'user' })),\n      ) || [];\n    if (memberRefs.includes(userRef)) {\n      if (!user.spec.memberOf) {\n        user.spec.memberOf = [];\n      }\n      if (!user.spec.memberOf.includes(groupKey)) {\n        user.spec.memberOf.push(groupKey);\n      }\n    }\n  }\n}\n\n// Ensure that users have their transitive group memberships. Requires that\n// the groups were previously processed with buildOrgHierarchy()\nexport function buildMemberOf(groups: GroupEntity[], users: UserEntity[]) {\n  const groupsByName = new Map(groups.map(g => [g.metadata.name, g]));\n\n  users.forEach(user => {\n    const transitiveMemberOf = new Set<string>();\n\n    const todo = [\n      ...(user.spec.memberOf ?? []),\n      ...groups\n        .filter(g => g.spec.members?.includes(user.metadata.name))\n        .map(g => g.metadata.name),\n    ];\n\n    for (;;) {\n      const current = todo.pop();\n      if (!current) {\n        break;\n      }\n\n      if (!transitiveMemberOf.has(current)) {\n        transitiveMemberOf.add(current);\n        const group = groupsByName.get(current);\n        if (group?.spec.parent) {\n          todo.push(group.spec.parent);\n        }\n      }\n    }\n\n    user.spec.memberOf = [...transitiveMemberOf];\n  });\n}\n"],"names":["DEFAULT_NAMESPACE","stringifyEntityRef","parseEntityRef"],"mappings":"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"}